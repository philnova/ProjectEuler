import time
import math
import itertools

#======================================#

"""
Problem 41:

We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital and is also prime.

What is the largest n-digit pandigital prime that exists?
"""

DIGITS = "1 2 3 4 5 6 7 8 9".split()

def gen_pandigitals(n_digits):
	return [i for i in reversed(sorted(["".join(seq) for seq in itertools.permutations(DIGITS[0:n_digits])]))]

def is_prime(n):
	if n in (0,1):
		return False
	if n % 2 == 0:
		return False
	for i in range(3, n):
		if n % i == 0:
			return False
	return True

def largest_pandigital_prime():
	count = len(DIGITS)
	while count:
		pandigitals = gen_pandigitals(count)
		for pan in pandigitals:
			print pan
			if is_prime(int(pan)):
				return pan
		count-=1

#print largest_pandigital_prime()

#======================================#

"""
Problem 42:

The nth term of the sequence of triangle numbers is given by, tn = 1/2n(n+1); so the first ten triangle numbers are:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is 19 + 11 + 25 = 55 = t10. If the word value is a triangle number then we shall call the word a triangle word.

Using words.txt (right click and 'Save Link/Target As...'), a 16K text file containing nearly two-thousand common English words, how many are triangle words?

"""

def gen_triangle_number():
	n = 1
	while True:
		tri = (n*(n+1))/2
		yield tri
		n+=1

def triangle_range(limit):
	g = gen_triangle_number()
	triangle_nums=[]
	for dummy in range(limit):
		triangle_nums.append(g.next())
	return triangle_nums

ALPHABET = "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z".split()

def wordscore(word):
	return sum([ALPHABET.index(char)+1 for char in word])

def count_triangle_words(wordfile):
	word_list = []
	with open(wordfile,'r') as fo:
		for line in fo:
			word_list = [i[1:-1] for i in line.split(",")]
	
	triangles = triangle_range(300)

	counter = 0
	for word in word_list:
		#print word
		if wordscore(word) in triangles:
			print word, wordscore(word)
			counter += 1
	return counter


#print count_triangle_words("words42.txt")

#======================================#

"""
Problem 43:

The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.

Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following:

d2d3d4=406 is divisible by 2
d3d4d5=063 is divisible by 3
d4d5d6=635 is divisible by 5
d5d6d7=357 is divisible by 7
d6d7d8=572 is divisible by 11
d7d8d9=728 is divisible by 13
d8d9d10=289 is divisible by 17
Find the sum of all 0 to 9 pandigital numbers with this property.

"""

DIGITS = "1 2 3 4 5 6 7 8 9 0".split()

def gen_pandigitals(n_digits):
	return [i for i in reversed(sorted(["".join(seq) for seq in itertools.permutations(DIGITS[0:n_digits])]))]

def check_property(digit_string):
	if int(digit_string[1:4])%2==0:
		if int(digit_string[2:5])%3==0:
			if int(digit_string[3:6])%5==0:
				if int(digit_string[4:7])%7==0:
					if int(digit_string[5:8])%11==0:
						if int(digit_string[6:9])%13==0:
							if int(digit_string[7:10])%17==0:
								return int(digit_string)
	return 0

#print check_property('1406357289')
#print check_property('1406357288')

def find_sum_of_pandigital_with_property():
	total = 0
	pandigitals = gen_pandigitals(10)
	for pan in pandigitals:
		total += check_property(pan)
	return total

#print find_sum_of_pandigital_with_property()

#======================================#

"""
Problem 44

Pentagonal numbers are generated by the formula, Pn=n(3n-1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 - 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk - Pj| is minimised; what is the value of D?
"""

def gen_pentagonal():
	counter = 1
	while True:
		yield counter * (3*counter-1)/2
		counter+=1

def check_pentagonal(limit1=1000, limit2=10000):
	g = gen_pentagonal()
	pentagonals = []
	for dummy in xrange(limit1):
		pentagonals.append(g.next())

	altern_pentagonals = []
	for dummy in xrange(limit2-limit1):
		altern_pentagonals.append(g.next())

	smallest_distance = float('inf')
	for idx1, p1 in enumerate(pentagonals):
		for idx2, p2 in enumerate(pentagonals):
			if not idx1==idx2:
				print p1+p2, abs(p1-p2), p1+p2 in pentagonals or p1+p2 in altern_pentagonals, abs(p1-p2) in pentagonals or abs(p1-p2) in altern_pentagonals
				if (p1+p2 in pentagonals or p1+p2 in altern_pentagonals) and (abs(p1-p2) in pentagonals or abs(p1-p2) in altern_pentagonals):
					if abs(idx1-idx2) < smallest_distance:
						smallest_distance = abs(idx1-idx2)

	return smallest_distance

#print check_pentagonal()

## New approach: instead of listing pentagonals, use the inverse function to test whether a number is pentagonal

def is_n_pentagonal(n):
	"""n is pentagonal if the inverse pentagonal function returns an integer"""
	pen_test = (math.sqrt(24*n+1)+1)/6.0
	return pen_test == float(int(pen_test))

# notfound = True
# result = 0
# i=1

# while notfound:
# 	i+=1
# 	n = i * (3*i-1)/2.0

# 	for j in xrange(i-1,0,-1):
# 		m = j * (3*j-1)/2.0
# 		if is_n_pentagonal(abs(n-m)) and is_n_pentagonal(n+m):
# 			result = n-m
# 			notfound = False
# 			break

# print result, i

#======================================#

"""
Problem 45:

Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Pentagonal	 	Pn=n(3n-1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	Hn=n(2n-1)	 	1, 6, 15, 28, 45, ...
It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.
"""

def is_n_pentagonal(n):
	"""n is pentagonal if the inverse pentagonal function returns an integer"""
	pen_test = (math.sqrt(24*n+1)+1)/6.0
	return pen_test == float(int(pen_test))

def is_n_hexagonal(n):
	hex_test = (math.sqrt(8*n+1)+1)/4.0
	return hex_test == float(int(hex_test))

def generate_triangle_numbers():
	num = 1
	counter = 2
	while True:
		yield num
		num += counter
		counter +=1

# t = generate_triangle_numbers()
# for i in xrange(100):
# 	print t.next()

def find_tri_pen_hex():
	trigen = generate_triangle_numbers()
	while True:
		t = trigen.next()
		if is_n_pentagonal(t) and is_n_hexagonal(t) and t>40755:
			return t

#print find_tri_pen_hex()

#======================================#

"""
Problem 46:
It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.

9 = 7 + 2x12
15 = 7 + 2x22
21 = 3 + 2x32
25 = 7 + 2x32
27 = 19 + 2x22
33 = 31 + 2x12

It turns out that the conjecture was false.

What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?
"""

def all_primes(start, end):
        primes = list(sorted(set(range(start,end+1)).difference(set((p * f) for p in range(2, int(end ** 0.5) + 2) for f in range(2, (end/p) + 1)))))
        if 1 in primes:
        	primes.remove(1)
        return primes

def all_twice_squares(start,end):
	squares = []
	for n in xrange(start,end+1):
		#print n, 2*(n**2)
		#if 2*(n**2) <= end:
		squares.append(2*(n**2))
	return list(sorted(squares))

PRIME_LIST = []
SQUARES_LIST = []
PREV_LIMIT = 1

def extend_primes_and_squares(limit):
	"""Fill out the PRIME_LIST and SQUARES_LIST with all primes and perfect squares below
	the provided integer, limit."""
	global PREV_LIMIT
	PRIME_LIST.extend(all_primes(PREV_LIMIT,limit))
	SQUARES_LIST.extend(all_twice_squares(PREV_LIMIT,limit))
	PREV_LIMIT = limit

#print PRIME_LIST, SQUARES_LIST
#extend_primes_and_squares(10)
#print PRIME_LIST, SQUARES_LIST
#extend_primes_and_squares(50)
#print PRIME_LIST, SQUARES_LIST

def test_conjecture(n):
	if not is_prime(n):
		extend_primes_and_squares(n)
		for p in PRIME_LIST:
				for s in SQUARES_LIST:
					if p+s == n:
						return True
		return False
	else:
		return True

#print test_conjecture(9)
#print test_conjecture(15)

def disprove_conjecture():
	n = 3
	while True:
		print n
		if not test_conjecture(n):
			return n
		else:
			n+=2

#print disprove_conjecture()

#======================================#

"""
Problem 47:

The first two consecutive numbers to have two distinct prime factors are:

14 = 2 x 7
15 = 3 x 5

The first three consecutive numbers to have three distinct prime factors are:

644 = 2^6 x 7 x 23
645 = 3 x 5 x 43
646 = 2 x 17 x 19.

Find the first four consecutive integers to have four distinct prime factors. What is the first of these numbers?
"""

def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors

#for i in xrange(20):
#	print i, prime_factors(i)

def find_consecutive_prime_factors(length=4):
	n = 2

	while True:
		print n
		if len(set(prime_factors(n))) == length:
			#print [len(set(prime_factors(n+dummy)))==length for dummy in xrange(length)]
			if all([len(set(prime_factors(n+dummy)))==length for dummy in xrange(length)]):
				return n

		
		n+=1

#print find_consecutive_prime_factors(4)

#======================================#

"""
Problem 48:

The series, 11 + 22 + 33 + ... + 1010 = 10405071317.

Find the last ten digits of the series, 11 + 22 + 33 + ... + 10001000.
"""

def self_powers(limit=1001):
	total = 0
	for i in xrange(1,limit):
		total+=i**i
	return total
#print self_powers()

#======================================#

"""
Problem 49:

The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways: (i) each of the three terms are prime, and, (ii) each of the 4-digit numbers are permutations of one another.

There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, but there is one other 4-digit increasing sequence.

What 12-digit number do you form by concatenating the three terms in this sequence?
"""

def is_prime(n):
	if n in (0,1):
		return False
	if n % 2 == 0:
		return False
	for i in range(3, n):
		if n % i == 0:
			return False
	return True

DIGITS = "1 2 3 4 5 6 7 8 9".split()
DIGITS = DIGITS * 2

def gen_all_ndigit(n_digits):
	return [i for i in sorted(["".join(seq) for seq in itertools.permutations(DIGITS,n_digits)])]

def all_four_digit_primes():
	return [int(n) for n in gen_all_ndigit(4) if is_prime(int(n))]

def are_permutations(tup):
	"""Return true if all members of a tuple are permutations of each other"""
	possibilities = [int("".join(i)) for i in itertools.permutations(str(tup[0]))]
	return all([i in possibilities for i in tup])

def digits_in_iter(iterable):
	"""Return the total number of digits in an iterable"""
	seen_so_far = []
	for item in iterable:
		for char in str(item):
			seen_so_far.append(char)
	return len(set(seen_so_far))

#print digits_in_iter((1234,1342))
#print digits_in_iter((1234,1542))

def increasing_prime_sequence():
	answers = []
	primes = set(all_four_digit_primes())
	print len(primes)
	for idx1, prime1 in enumerate(primes):
		for idx2, prime2 in enumerate(primes):
			if idx1!=idx2 and prime2>prime1 and abs(prime1-prime2)+prime2 in primes:
				answers.append((prime1, prime2, abs(prime1-prime2)+prime2))
			elif idx1!=idx2 and prime2<prime1 and abs(prime1-prime2)+prime1 in primes:
				answers.append((prime2, prime1, abs(prime1-prime2)+prime1))
	return set(answers)

def increasing_prime_permutations():
	return [i for i in increasing_prime_sequence() if are_permutations(i)]

#print increasing_prime_permutations()

#======================================#

"""
Problem 50:
The prime 41, can be written as the sum of six consecutive primes:

41 = 2 + 3 + 5 + 7 + 11 + 13
This is the longest sum of consecutive primes that adds to a prime below one-hundred.

The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.

Which prime, below one-million, can be written as the sum of the most consecutive primes?
"""

def all_primes(start, end):
        return list(sorted(set(range(start,end+1)).difference(set((p * f) for p in range(2, int(end ** 0.5) + 2) for f in range(2, (end/p) + 1)))))

def longest_prime_sequence(limit=1000000):
	primes = all_primes(2,limit)
	max_length = 0
	top_prime = 2

	#slide a window
	for start_idx, start_prime in enumerate(primes):
		total = [start_prime]
		counter = 1
		while sum(total) < limit:
			total.append(primes[start_idx+counter])
			counter+=1
			if is_prime(sum(total)) and len(total) > max_length:
				max_length = len(total)
				top_prime = sum(total)
				print top_prime, max_length
	return top_prime, max_length

#print longest_prime_sequence()
